#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include "mkl.h"
#include <assert.h>
#include "timer_GHz.inc"
#include <complex.h>

#define SEED 77777

static void _print_mkl_version() {
  int len = 198;
  char buf[198];

  mkl_get_version_string(buf, len);
  printf("\nMKL Version: %s\n", buf);
}

#define EXPERIMS_N 26

typedef struct experiment_t {
  long array_size;
  long repetitions;
} experiment_t;

static void populate_experiment_sizes(experiment_t *list, int s0, size_t n) {
  int i;
  long s, r;
  long r_max = (1 << 16);

  s = (1 << s0);
  r = (2 << n);

  for(i=0; i < n; i++) {
    list[i].array_size = s;
    list[i].repetitions = (r > r_max) ? r_max : r;
    s <<= 1;
    r >>= 1;
  }

  return;
}

int main(int args, char **argv) {
  VSLStreamStatePtr stream;
  double *x1, *x2, *y, CPE, CPE_min;
  double c = 4321.43;
  int err = 0;
  size_t j, i, k, l;
  long int arraySize = 0;
  const double d_zero = 0.0, d_one = 1.0;
  experiment_t experims[EXPERIMS_N];
  char *run_no, *exper_str, *which_to_use;
  char *batchID, *arch, *coreNum;
  rdtsc_type t0, t1;  
  batchID = argv[1];
  arch = argv[2];
  coreNum = argv[3];
  arraySize = atol(argv[4]);

  populate_experiment_sizes(experims, 2, EXPERIMS_N);

  err = vslNewStream(&stream, VSL_BRNG_SFMT19937, SEED);
  assert(err == VSL_STATUS_OK);

  {
    size_t reps;
    long int n;
    n = arraySize;
    reps = 10000;

    x1 = (double *) mkl_malloc( n*sizeof(double), 64);
    x2 = (double *) mkl_malloc( n*sizeof(double), 64);
    y  = (double *) mkl_malloc( n*sizeof(double), 64);

    err = vdRngExponential(VSL_RNG_METHOD_EXPONENTIAL_ICDF_ACCURATE, stream, n, x1, d_zero, d_one);
    assert(err == VSL_STATUS_OK);
    err = vdRngExponential(VSL_RNG_METHOD_EXPONENTIAL_ICDF_ACCURATE, stream, n, x2, d_zero, d_one);
    assert(err == VSL_STATUS_OK);
  }

/**begin repeat
 *  #func = +, -, *#
 *  #vml = Add, Sub, Mul#
 */

/**begin repeat1
 *  #string1 = array#
 *  #string2 = array#
 */

  {
    size_t reps;
    long int n;
    n = arraySize;
    reps = 10000;
    CPE_min = 100000000.0;
    for (j=0; j < reps; j++) {  
      t0 = timer_rdtsc();
      vd@vml@(n, x1, x2, y);
      t1 = timer_rdtsc();
      CPE = ((double)(t1 - t0)/n);
      CPE_min = CPE < CPE_min ? CPE : CPE_min;
    }
    printf("%s,%s,Native-C,@string1@@func@@string2@,%s,Double,%ld,%.4g\n", batchID, arch, coreNum, n, CPE_min);
  }

/**end repeat1**/
/**end repeat**/

/**begin repeat
 *  #func = +#
 */

/**begin repeat1
 *  #string1 = array#
 *  #string2 = scalar#
 *  #in1 = n#
 *  #in2 = x1#
 *  #in3 = x1#
 *  #in4 = 1.0#
 *  #in5 = c#
 *  #in6 = 0.0#
 *  #in7 = 1.0#
 *  #in8 = y#
 */

  {
    size_t reps;
    long int n;
    n = arraySize;
    reps = 10000;
    CPE_min = 100000000.0;
    for (j=0; j < reps; j++) {  
      t0 = timer_rdtsc();
      vdLinearFrac(@in1@, @in2@, @in3@, @in4@, @in5@, @in6@, @in7@, @in8@);
      t1 = timer_rdtsc();
      CPE = ((double)(t1 - t0)/n);
      CPE_min = CPE < CPE_min ? CPE : CPE_min;
    }
    printf("%s,%s,Native-C,@string1@@func@@string2@,%s,Double,%ld,%.4g\n", batchID, arch, coreNum, n, CPE_min);
  }

/**end repeat1**/
/**end repeat**/

/**begin repeat
 *  #func = -#
 */

/**begin repeat1
 *  #string1 = array#
 *  #string2 = scalar#
 *  #in1 = n#
 *  #in2 = x1#
 *  #in3 = x1#
 *  #in4 = 1.0#
 *  #in5 = -c#
 *  #in6 = 0.0#
 *  #in7 = 1.0#
 *  #in8 = y#
 */

  {
    size_t reps;
    long int n;
    n = arraySize;
    reps = 10000;
    CPE_min = 100000000.0;
    for (j=0; j < reps; j++) {  
      t0 = timer_rdtsc();
      vdLinearFrac(@in1@, @in2@, @in3@, @in4@, @in5@, @in6@, @in7@, @in8@);
      t1 = timer_rdtsc();
      CPE = ((double)(t1 - t0)/n);
      CPE_min = CPE < CPE_min ? CPE : CPE_min;
    }
    printf("%s,%s,Native-C,@string1@@func@@string2@,%s,Double,%ld,%.4g\n", batchID, arch, coreNum, n, CPE_min);
  }

/**end repeat1**/
/**end repeat**/

/**begin repeat
 *  #func = *#
 */

/**begin repeat1
 *  #string1 = array#
 *  #string2 = scalar#
 *  #in1 = n#
 *  #in2 = x1#
 *  #in3 = x1#
 *  #in4 = c#
 *  #in5 = 0.0#
 *  #in6 = 0.0#
 *  #in7 = 1.0#
 *  #in8 = y#
 */
  {
    size_t reps;
    long int n;
    n = arraySize;
    reps = 10000;
    CPE_min = 100000000.0;
    for (j=0; j < reps; j++) {  
      t0 = timer_rdtsc();
      vdLinearFrac(@in1@, @in2@, @in3@, @in4@, @in5@, @in6@, @in7@, @in8@);
      t1 = timer_rdtsc();
      CPE = ((double)(t1 - t0)/n);
      CPE_min = CPE < CPE_min ? CPE : CPE_min;
    }
    printf("%s,%s,Native-C,@string1@@func@@string2@,%s,Double,%ld,%.4g\n", batchID, arch, coreNum, n, CPE_min);
  }

/**end repeat1**/
/**end repeat**/

/**begin repeat
 *  #func = log10, exp, erf, invsqrt#
 *  #vml =  Log10, Exp, Erf, InvSqrt#
 */

  {
    size_t reps;
    long int n;
    n = arraySize;
    reps = 10000;
    CPE_min = 100000000.0;
    for (j=0; j < reps; j++) {  
      t0 = timer_rdtsc();
      vd@vml@(n, x1, y);
      t1 = timer_rdtsc();
      CPE = ((double)(t1 - t0)/n);
      CPE_min = CPE < CPE_min ? CPE : CPE_min;
    }
    printf("%s,%s,Native-C,@func@,%s,Double,%ld,%.4g\n", batchID, arch, coreNum, n, CPE_min);
  }

  // Do not need to use SVML for now
  /*for(k=0; k < EXPERIMS_N; k++) {
    size_t n, reps;
    n = experims[k].array_size;
    reps = experims[k].repetitions;

    CPE_min = 100000000.0;
    for (j=0; j < reps; j++) {  
      t0 = timer_rdtsc();
      for(l=0; l < n; l++) {
        y[l] = @func@(x1[l]);
      }
      t1 = timer_rdtsc();
      CPE = ((double)(t1 - t0)/n);
      CPE_min = CPE < CPE_min ? CPE : CPE_min;
    }
    printf("C, SVML, @func@, %ld, %.4g\n", n, CPE_min);
  }*/

/**end repeat**/

  if (x1)
    mkl_free(x1);
  if (x2)
    mkl_free(x2);
  if (y)
    mkl_free(y);

  err = vslDeleteStream(&stream);
  assert(err == VSL_STATUS_OK);
}
